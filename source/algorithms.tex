\subsection{Formal definition of the \acronymWSNOptimisation{}{} algorithm}
\label{section:solution_formal}

We formally define the \acronymWSNOptimisation{}{} algorithm in two parts, Algorithm \ref{alg:wsn_optimisation_sink} for sink node agents receiving composite tasks, and Algorithm \ref{alg:wsn_optimisation_arc} for other agents belonging to the task-path for an atomic task.

In the \acronymWSNOptimisationSink{}{} algorithm, Algorithm \ref{alg:wsn_optimisation_sink}, the sink node receives a composite task $\varCompositeTask{}{}$ comprising of multiple atomic tasks $\varAtomicTask{}{}$ to be completed. While these atomic tasks are not complete or allocated, the sink node agent runs the \acronymATARIA{}{} algorithm to select an action (Line \ref{wsnsink:select}).  If the action chosen is to execute the atomic task itself, $\functionExec{}{}$, the algorithm uses the \acronymMGRAO{}{} algorithm to determine the resources that will be allocated to the tasks' completion. An $\functionAlloc{}{}$ action will allocate it to another agent it knows about to complete using the \acronymWSNOptimisationArc{}{} algorithm. In both cases, the task is removed from the active list  (Line \ref{wsnsink:exec_remove}). If a $\functionInfo{}{}$ or $\functionLink{}{}$ action is executed, these will update the agents' neighbourhood and knowledge base respectively using the \acronymATARIA{}{} algorithm. There is no effect on atomic task execution or allocation in that case, and the algorithm loops round to choose another action. The selection and execution of actions using the \acronymATARIA{}{} algorithm is repeated until the tasks are either executed or allocated. Once all the atomic tasks are allocated, the sink node must wait for them to complete (Line \ref{wsnsink:wait}). When all the atomic tasks have completed, each atomic tasks' absolute task value to the composite task is calculated (Line \ref{wsnsink:ataria-taskval}). All of the agents in the task-path of each atomic task have their Q-values updated for the actions they took in completing each task (Line \ref{wsnsink:ataria-update}). Finally, for each atomic task, the corresponding absolute task value is sent to the last agent in the atomic tasks' task-path so that each sensor agent can carry out an \acronymMGRAO{}{}-update to re-allocate its resources to increase the tasks' value in the future (Line \ref{wsnsink:mgrao}). 

\begin{algorithm}[ht]
	\DontPrintSemicolon
	\footnotesize
	
	\caption{\textbf{The \acronymWSNOptimisationSink{}{} algorithm}}
	\label{alg:wsn_optimisation_sink}
	{
		\KwIn{ $\varCompositeTask{}{}$ , The composite task set}
		\KwIn{ $\varAgent{}{}$ , The sink agent completing the composite task}
		\KwResult{$\functionCompositeTaskQuality{}{}{}{}$ , The composite task quality of $\varCompositeTask{}{}$}		\nonl \;
		\tcp{Copy set of atomic tasks to list of incomplete tasks}
		$ctactive \leftarrow \varCompositeTask{}{}$ \label{wsnsink:copy}\;
		\ForEach{$\varAtomicTask{}{} \in ctactive$\label{wsnsink:composite_tasks}}
		{
			\tcp{Select and execute action through \acronymATARIA{}{}}
			$\varAction{}{} \leftarrow \functionATARIAAction{}{}$ \label{wsnsink:select} \;	
			\If{$\functionAgentActionType{}{} = \functionExec{}{} \lor  \functionAgentActionType{}{} = \functionAlloc{\varAtomicTask{}{}}{\varAgent{}{'}}$?}
			{
				\tcp{If the action was completed by agent $\varAgent{}{}$ or by allocating to another agent $\varAgent{}{'}$, remove atomic task from active task list}
				$ctactive{}{} \leftarrow ctactive - \lbrace \varAtomicTask{}{} \rbrace$ \label{wsnsink:exec_remove}\;
			}
		}
	\tcp{Wait for all the atomic tasks in the composite task to be completed}
		\While{ $\functionNotComplete{\varCompositeTask{}{}}{}$}{
			$\functionWait{}{}$ \label{wsnsink:wait}\; 
		}
		\ForEach{$\varAtomicTask{}{} \in \varCompositeTask{}{}$\label{ataria:composite_tasks}}
		{
			\tcp{Calculate each atomic tasks' absolute task value}
			$\varTaskValue{}{} \leftarrow \functionTaskAbsoluteValue{}{}
			$ \label{wsnsink:ataria-taskval}\;	
			\tcp{Send a proportion of the absolute task value for the atomic task to each agent in its task-path}
			\ForEach{$\varAgent{}{'}\in \functionTaskArc{}{}$}{
				\tcp{Update the Q-values for actions taken by agents in each atomic tasks' task-path}
				$\functionSignature{\texttt{ataria-update}}{
					\varAgent{}{'}, \varAtomicTask{}{}, \frac{\varTaskValue{}{}}{\funcSize{\varCompositeTask{}{}}}
				}$ \label{wsnsink:ataria-update}\;	
			}
			\tcp{Send the agent that completed the atomic task the absolute task value to run the MGRAO update}
			$\functionSignature{\texttt{mgrao-update}}{\functionSinkRole{}{}, \varAtomicTask{}{}, \varTaskValue{}{}}$ \label{wsnsink:mgrao}\;	
		}
		\Return{$\functionCompositeTaskQuality{}{}{}{}$}
	}
\end{algorithm}

The \acronymWSNOptimisationArc{}{} algorithm (Algorithm \ref{alg:wsn_optimisation_arc}) will complete an atomic task and return its quality, either by executing the task itself, or re-allocating to another agent.  Once again,  the \acronymATARIA{}{} algorithm is used to repeatedly select actions until the atomic task is either executed or allocated (Line \label{wsnarc:select}). After waiting for the atomic task to be completed (Line \ref{wsnarc:wait}),  an atomic task quality is returned (Line \ref{wsnarc:wait}).

\begin{algorithm}[ht]
	\DontPrintSemicolon
	\footnotesize
	
	\caption{\textbf{The \acronymWSNOptimisationArc{}{} algorithm } }
	\label{alg:wsn_optimisation_arc}
	{
		\KwIn{ $\varAtomicTask{}{}$ , The atomic task to be completed}
		\KwIn{ $\varAgent{}{}$ , The agent completing the atomic task}
		\KwResult{$\functionAtomicTaskQualitySignature{}{}$ , The atomic task quality of $\varAtomicTask{}{}$}
		\nonl \;
		
		$taskAllocated \leftarrow False$ \;
		\While{$\neg taskAllocated$ }{
			\tcp{Select and execute action through \acronymATARIA{}{}}
			$\varAction{}{} \leftarrow \functionATARIAAction{}{}$ \label{wsnarc:select} \;
			\tcp{If the action was executed by agent $\varAgent{}{}$ or allocated to another agent $\varAgent{}{'}$, mark it allocated}
			\uIf{$\functionAgentActionType{}{} = \functionExec{}{} \lor \functionAgentActionType{}{} = \functionAlloc{\varAtomicTask{}{}}{\varAgent{}{'}}$?}
			{
				$taskAllocated \leftarrow True$ \;
			}
		}
		\tcp{Wait for the atomic task to be completed}
		\While{ $\functionNotComplete{\varAtomicTask{}{}}{}$}{
			$\functionWait{}{}$ \label{wsnarc:wait}\; 
		}
		\tcp{Return the task quality of the atomic task completion}
		\Return{$\functionAtomicTaskQualitySignature{}{}$\label{wsnarc:return}} \;
	}
\end{algorithm}